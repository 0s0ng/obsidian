# 0. 배경: IP 할당
---
- 네트워크 통신하려면 IP 주소 필요함
- 할당 방식
	- static
		-  사용자가 **직접** 설정
	- dynamic
		- ![[Pasted image 20251204145148.png]]
		- DHCP를 통해 ip, subnet mask, gateway, dns 서버 주소 자동으로 할당 가능
- DHCP(Dynamic Host Configuration Protocol)
	- 하는일
		- IP주소, subnetmask, gateway, dns 정보를 자동으로 할당
	- 기반
		- BOOTP(Bootstrap Protocol)을 기반으로 함.
		- 클라이언트 서비스 포트: 68(bootpc)
		- 서버 서비스 포트: 67(bootps)
		- DHCP는 BOOTP에서 기능이 추가된 확장 프로토콜. 둘 다 사용되는 서비스 포트가 같고 서로의 클라이언트가 서로의 서버를 사용하여 정보를 수신할 수 있는 등 호환성이 좋음
	- 동작 방식
		- 1. DHCP Discover
			- 클라이언트는 DHCP 서버를 찾기 위해 DHCP discover 메세지를 브로드캐스트로 전송
		- 2. DHCP Offer
			- discover 메세지를 수신한 DHCP 서버는 ip 주소, 서브넷, 게이트웨이, dns 정보, lease time 등의 정보를 포함한 DHCP 메시지를 클라이언트로 전송
			- DHCP 서버는 DHCP IP Pool 중에 할당할 IP를 선택함. 별도의 설정이 없으면 임의로 할당하지만 특정 클라이언트의 mac주소와 ip 주소를 사전에 정의해두면 설정된 ip를 할당하므로 dhcp를 사용하면서도 고정된 ip를 할당할 수 있음
			- 만약 DHCP 서버가 2대 이상이라 offer가 2개 이상 도착한다면 클라이언트는 일반적으로 가장 먼저 도착한 유효한 오퍼를 선택함
		- 3. DHCP Request
			- 제안받은 IP 주소와 DHCP 서버 정보를 포함한 DHCP 요청 메세지를 브로드캐스트로 전송
			- 선택받은 서버는 클라이언트에 할당됨을 인지
			- 선택받지 못한 서버는 해당 ip 주소를 다시 사용가능한 pool로 회수

		- 4. DHCP ack
			- DHCP 클라이언트로부터 IP 주소를 사용하겠다는 요청을 받으면 DHCP 서버에 해당 IP를 어떤 클라이언트가 언제부터 사용하기 시작했는지 정보를 기록하고 DHCP request 메세지를 정상적으로 수신했다는 응답을 전송
			- 유니캐스트 방식으로 전송됨
	- 프로토콜
		- UDP 사용. 왜? IP를 할당받는 과정이므로 패킷을 정상적으로 주고받을 수 없음
	- IP 주소 할당 방식
		- 순서대로 할당 (가장 낮은 주소부터 순차적)
		- 이미 임대(lease)되거나 예외 처리된 주소는 건너뛰고 할당
		- 주소 재사용
			- 이미 ip 주소를 할당받았던 호스트가 임대 기간이 끝나기 전에 네트워크에 다시 접속하거나 갱신 요청 시 dhcp 서버는 가능한 호스트가 이전에 사용하던 ip주소를 다시 할당해주려고 함.
			- 왜? 주소가 자주 바뀌는 것을 방지하여 네트워크 관리 및 안정성을 높이기 위해서.
# 1. PHASE 1: DNS 서버 요청
---
## 1.1 브라우저에 www.google.com 을 입력
---
## 1.2 브라우저가 DNS Query 메시지 생성
---
브라우저는 dns 서버(53)에 조회하는 네트워크 송출 기능은 없음
-> OS에게 넘김 (OS에게 넘기기 위해서 Socket 라이브러리 이용)

DNS 서버에 조회를 요청할 때 Socket 라이브러리의 **리졸버(resolver)** 를 사용
브라우저가 리졸버 호출하면 리졸버에서 DNS 서버에 조회하기 위한 메세지를 만듬
이때 만든 메세지를 DNS 서버에 전송하기 위해서 리졸버는 OS 내부의 프로토콜 스택을 호출하여 실행함
- resolver
	- 정의
		- 도메인명을 IP주소로 바꿔주는 역할을 수행하는 클라이언트 프로그램 또는 라이브러리
	- 조회 과정
		- 자신의 로컬캐시에 해당 도메인의 IP주소가 있는지 확인
		- 있으면 즉시 ip 반환 및 조회 종료
		- 없으면 (재귀적 쿼리를 처리하는) DNS 서버에 쿼리 요청
			- 반복 조회(www.google.com)
				- Root DNS 서버 > TLD(Top-Level Domain) 서버 (.com) > Authoritative DNS 서버(goole.com)
			- ip 주소를 찾아낸 DNS 서버는 정보를 리졸버에게 전달
			- 리졸버는 해당 ip 주소를 사용자에게 반환하고 로컬 캐시에 저장

## 1.3 DNS Query는 일반적으로 UDP Protocol을 사용
---
DNS는 UDP, TCP 프로토콜을 모두 사용하지만 주로 UDP 프로토콜을 사용함

UDP 패킷은 512 바이트 보다 클 수 없음 (더 큰 데이터 전송하려면 TCP 필요)
DNS 쿼리는 매우 작고 간단하여 일반적으로 512 바이트 이하임
**속도 및 효율성, 오버헤드 감소, 가벼움**의 이유로 UDP를 사용함

- UDP의 비신뢰성 보완
	- UDP 특징
		- UDP는 데이터가 제대로 도착했는지, 중간에 손실되지는 않았는지 확인하지 않음
		- 3-way-handshake를 하지 않아 빠르지만 신뢰성은 없음
	- 리졸버(resolver)로 보완
		- 쿼리 전송과 타이머 설정
			- 리졸버가 쿼리 전송하는 동시에 내부적으로 타이머 설정
		- timeout 발생 (패킷 손실 추정)
			- 설정된 시간 내에 DNS 서버로 부터 ip 주소 응답이 도착하지 않으면 리졸버는 데이터 패킷이 중간에 손실되었거나 DNS 서버가 응답을 못한다고 판단
		- 자동 재전송
			- 손실된 것으로 추정되는 동일한 쿼리를 지정된 횟수만큼 다시 DNS 서버로 전송
		- 서버 전환
			- 여러 번 재전송해도 여전히 응답없으면 미리 설정된 다음 DNS 서버로 전환하여 쿼리를 전송함

-> UDP로 빠른 속도를 챙기고 resolver를 통해 tcp 재전송 기능을 대신하여 비신뢰성 부분을 어느정도 보완

- DNS가 TCP를 사용하는 경우(더 큰 응답 크기가 필요한 경우)
	- DNSSEC: 보안 기능을 위한 추가 데이터가 포함되어 메세지가 커짐
	- zone transfer: AXFR(전체 존 전송), IXFR(증분 존 전송) 시에 tcp를 사용하여 데이터의 완전성과 일관성을 보장
		- AXFR: 일정 시간마다 한 번씩 zone 파일이 수정됐는지 확인 후 zone 파일 전체 전송
		- IXFR: notify 메시지와 함께 사용되며 변경된 내용만 slave에 전송

## 1.4 Encapsulation으로 물리 계층까지 Data 전송
---
## 1.5 AS내부 IGP, AS외부 BGP 이동
---
- AS(Autonomous System)
	- 하나의 관리 규정 아래서 운용되는 라우터의 집단 또는 하나의 관리 전략으로 구성된 라우터 집단
- ASBR(Autonomous System Boundary Router)
	- AS 문지기 라우터, AS 밖으로 나갈때 해당 라우터에 정보를 물어봐서 밖(인터넷)으로 나감
	- 자신의 AS와 인접해 있는 다른 AS에 대한 정보를 가지고 있으면서 자기 AS에서 밖으로 나가는 라우터나 외부 AS에서 자기 AS 쪽으로 들어오는 라우터에게 정보를 제공하는 역할을 함
- IGP(Interior Gateway Protocol=Interior Routing Protocol)
	- 라우터가 AS 내부에서 사용하는 라우터 프로토콜
	- 본사와 지사 간에 라우터를 설치해야할 경우에 사용
	- 종류: RIP, IGRP, EIGRP, OSPF
- EGP(Exterior Gateway Protocol=Exterior Routing Protocol)
	- 라우터가 AS 외부에서 사용하는 라우팅 프로토콜
	- 본사와 라우터가 ISP와 연결을 해서 인터넷을 사용해야할 경우에 사용
	- BGP(Border gateway protocol): 현재 인터넷의 표준으로 사용되는 현대적인 경로 벡터 라우팅 프로토콜

## 1.6 DNS Server에 도착
---
# PHASE 2: DNS 서버 응답
---
## 2.1 Decapsulation으로 응용 계층까지 Data 전송 
---
## 2.2 DNS Server 반복적 쿼리 실행
---
## 2.3 DNS Response 메시지를 생성
---
## 2.4 Re-encapsulation으로 물리 계층까지 Data 전송
---
## 2.5 AS내부 IGP, AS외부 BGP 이동
---
## 2.6 Client에 도착 후 Decapsulation
---
# PHASE 3: HTTP 연결 수립
---
## 3.1 브라우저가 google 공인 IP로 HTTP GET 요청 메시지를 생성

## 3.2 HTTP GET 요청 메시지는 TCP Protocol을 사용

## 3.3 TCP 연결 수립을 위해 HTTP 요청 메시지 보류

## 3.4 전송 계층에서 Client -> Server(SYN 요청)

## 3.5 전송 계층에서 Client <- Server(SYN + ACK 응답)

## 3.6전송 계층에서 Client -> Server(ACK 응답)

# PHASE 4: HTTP 요청/응답
---
## 4.1 TCP 연결 이후 HTTP GET 요청 메시지 전송

## 4.2 Encapsulation으로 물리 계층까지 Data 전송

## 4.3 AS내부 IGP, AS외부 BGP 이동

## 4.4 google Server에 도착

## 4.5 Server에서 HTTP GET 응답 메시지 전송

## 4.6 브라우저에 Google Main 페이지 출력

# PHASE 5: 번외 HTTPS
---
## 5.1 응용 계층에서 TLS HandShake Protocol 수행

## 5.2 응용 계층에서 TLS Record Protocol 수행

## 5.3 Client에서 HTTPS GET 요청 암호화

## 5.4 Server에서 HTTPS GET 요청 복호화 및 HTTPS GET 응답 암호화

## 5.5 Client에서 HTTPS GET 응답 복호화

## 5.6 브라우저에 Google Main 페이지 출력