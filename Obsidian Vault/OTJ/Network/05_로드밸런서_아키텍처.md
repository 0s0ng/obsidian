![[Pasted image 20251207142556.png]]
# 1. HAProxy(High Availability Proxy)
## 1.1 기능1: 로드 밸런서 (Load Balancer)
### 1.1.1 필요성
- 서버 하나가 처리할 수 없을만큼 클라이언트의 수가 압도적으로 많은 경우 이를 해결하기 위해 서버의 사양을 높이는 **scale-up** 방법과 여러 서버에 트래픽을 분산해주는 **scale-out** 방법이 존재함
- HAProxy는 scale-out방법을 이용하며 요청을 여러 서버로 분산하여 부하를 균등하게 나누고 애플리케이션의 **가용성**과 성능을 향상시킴
### 1.1.2 작동 방식
1. 요청 수신: 클라이언트는 HAProxy의 VIP 주소로 웹 요청을 보냄. 또한 이 단계에서 L4(TCP) 또는 L7(http) 연결이 설정됨
2. 헬스 체크 및 서버 선택: 점검을 통해 서버들의 상태를 지속적으로 확인하고 정상 서버 목록만 남김
3. 알고리즘 적용: 설정된 로드 밸런싱 알고리즘을 적용
4. 요청 전달: 선택된 서버로 요청을 TCP 연결을 통해 전달함. 클라이언트의 실제 IP 주소를 X-Forwarded-For 헤더에 담아 웹 서버로 전달할 수 있음
5. 응답 반환: 서버가 처리한 응답은 다시 HAProxy를 통해 클라이언트에게 응답을 전달하여 연결을 종료
### 1.1.3 알고리즘
- static(정해진 규칙에 따름. 서버 상태 무관)
	- Round robin: 요청을 순차적으로 서버에 분배
	- Source: 클라이언트 ip 주소를 해싱하여 특정 서버에 할당
- dynamic(서버의 현재 상태를 모니터링하여 분배)
	- 최소 연결(Least connections): 현재 연결이 가장 적은 서버로 분배
	- 가중치 기반: 성능이 좋은 서버에 더 많은 트래픽 할당
## 1.2 기능2: 리버스 프록시 (Reverse Proxy)
### 1.2.1 필요성
- HAProxy는 클라이언트와 서버 사이에 위치하여 클라이언트의 요청을 대신 받아 웹 서버로 전달하고 서버의 응답을 다시 클라이언트에게 전달하는 역할을 함
- 클라이언트는 HAProxy의 주소만 알 뿐 실제 웹 서버의 주소는 알지 못함
- 보안 강화: 실제 서버의 ip 주소를 숨김
- SSL/TLS 오프로드: 암호화(https) 처리를 HAProxy가 대신 수행하여 웹 서버의 부하를 줄임
### 1.2.2 작동 방식
1. 트래픽 분기 및 라우팅
	- URL 기반 라우팅: 요청된 URL 경로에 따라 트래픽을 다른 웹 서버 그룹으로 보낼 수 있음
	- 헤더 기반 라우팅: 특정 HTTP 헤더 값이나 쿠키 유무에 따라 트래픽을 분리
2. SSL/TLS 오프로드
	- HTTPS 통신은 종결. 암호화된 데이터를 복호화하여 일반 HTTP 트래픽을 웹 서버로 전달
3. 세션 지속성
	- 쿠키나 소스 IP 해시를 사용하여 특정 클라이언트가 항상 동일한 웹 서버에 연결되도록 보장
# 2. HTTPD WordPress
## 2.1 HTTPD, Apache - 웹 서버
### 2.1.1 역할
- 클라이언트로부터 HTTP 요청을 수신하고 응답을 보내는 소프트웨어
### 2.1.2 기능
- 요청을 받으면 정적 파일(html, css, image)을 직접 제공하거나 동적 콘텐츠 생성을 위해 PHP 엔진으로 요청을 전달함
## 2.2 PHP 엔진 - WAS
### 2.2.1 역할
- wordpress는 php로 작성된 콘텐츠 관리 시스템(CMS)이므로 서버에서 PHP 코드를 해석하고 실행하는 환경이 필수적
### 2.2.2 기능
- 웹 서버로부터 전달받은 요청에 따라 워드프레스 코드를 실행하고 mysql db에 접속하여 필요한 데이터를 조회하거나 저장장
## 2.3 WordPress - CMS 애플리케이션
### 2.3.1 역할
- 실제 웹사이트 콘텐츠를 관리하고 동적인 웹 페이지를 생성하는 코어 시스템
### 2.3.2 특징
- 두 서버는 동일한 워드프레스 코드베이스를 가지고 있어야함
# 3. MySQL
## 3.1 역할
- 웹사이트 콘텐츠: 게시물, 페이지, 댓글의 텍스트 내용
- 사용자 데이터: 사용자 계정 정보, 로그인 자격 증명, 권한 수준
- 워드프레스 설정: 사이트 제목, URL, 테마 설정, 플러그인 설정 및 옵션
- 세션 데이터: 사용자 로그인 상태와 관련된 세션 정보
## 3.2 추가
- 트래픽 증가시 이중화 및 로드밸런싱 필요
- 이중화
	- 고가용성을 확보를 위해서 MySQL Master-Slave 복제 구성 필요
- 로드 밸런싱
	- 읽기 요청은 Slave 서버로 쓰기 요청은 Master 서버로 분산 시키는 로드 밸런싱 레이어 추가 고려

# 4. 네트워크 흐름 설명
![[Pasted image 20251209105628.png]]
## 4.1 가정
> 구글 서버가 해당 아키텍처로 구성되어 있다고 했을 때 C2 클라이언트에서 www.google.com URL로 요청 시 네트워크 흐름
> 각각의 ip는 위의 이미지에서 보이는 것과 같이 할당되어있음
## 4.2 토픽
C2 클라이언트에서 www.google.com URL을 입력했을 때 구글 페이지가 띄워지기까지의 네트워크 흐름 설명

## 4.3 DNS 서버
### 4.3.1 DNS 서버로의 통신

### 4.3.2 DNS 서버의 ip 주소는 외부 네트워크에 존재함 > 디폴트 게이트웨이(192.168.70.254)에 패킷을 넘김  > R2에서 라우팅 테이블을 확인하여 해당 패킷을  R1에게 넘김 > R1에서 일치하는 ip의 dns 서버로 패킷을 전달함

### 4.3.3 DNS 서버 작동 방식
2.2.1 DNS 쿼리를 받은 DNS 서버는 해당 쿼리를 재귀적으로 처리함 root 서버 > 최상위도메인서버 > 서브 서버 순

###4.3.4 ip 주소 반환 (DNS > R1 > R2 > C2)

## 4.4 Encapsulation
OSI 7 layer에 기반해서 설명
### 4.4.1 Application Layer 
- 동작: 사용자가 브라우저를 통해 www.google.com을 입력하고 엔터를 누르면 HTTP 프로토콜을 사용하여 웹 서버에 요청 보낼 데이터 생성
-  PDU: Data
-  생성 데이터:  GET / HTTP/1.1 (google.com의 메인 페이지를 요청하는HTTP 요청 라인), 기타 헤더 정보(Host, User-Agent)를 포함한 HTTP Request Message가 생성됨
### 4.4.2 Presentation Layer
-  동작: Data의 인코딩(Encoding), 암호화(Encryption), 압축(Compression) 등을 담당
-  PDU: Data
-  변환: 만약 HTTPS를 사용했다면 SSL/TLS 암호화가 이루어짐
### 4.4.3 Session Layer
- 동작: 통신 장치 간의 연결(세션)을 설정, 유지, 종료함
-  PDU: Data
-  변환: HTTP는 비연결성(Connectionsless) 프로토콜이지만 세션 계층에서 응용 프로그램 간의 논리적인 연결을 관리함. 새로운 헤더가 추가되지 않음
### 4.4.4 Transfer Layer
-  동작: Data를 Segment 단위로 분할하고 목적지 호스트의 응용 프로세스로 정확히 전달하기 위한 포트 번호를 추가함. 웹 통신은 일반적으로 TCP 프로토콜을 사용함
-  PDU: Segment
-  캡슐화: 상위 계층에서 내려온 Data에 TCP Header를 덧붙임
		- Source Port: 브라우저(클라이언트)의 포트 번호 (임의의 번호)
		- Destination Port: 웹 서버의 HTTP 서비스 포트 번호 (80)
		- Sequence Number, Acknowledgment Number, Checksum 등의 TCP 제어 정보를 포함
### 4.4.5 Network Layer
-  동작: 목적지 네트워크까지 데이터 전달하기 위한 IP 주소를 추가하고 데이터 경로를 결정(라우팅)함
-  PDU: Packet
-  캡슐화: 전송 계층에서 내려온 Segment에 IP Header를 덧붙임
	- Source IP Address: 브라우저(클라이언트) 컴퓨터의 IP 주소
	- Destination IP Address: 구글의 웹 서버 IP 주소 (DNS 쿼리를 통해 미리 확인된 값)
	- Protocol Number: 상위 계층 프로토콜이 TCP임을 나타냄

### 4.4.6 Data Link Layer
- 동작: 동일한 네트워크(LAN) 내에서 데이터를 오류 없이 전송하기 위한 MAC 주소를 추가
- PDU: Frame
- 캡슐화: 네트워크 계층에서 내려온 Packet의 앞에 Frame Header와 뒤에 Frmae Trailer를 덧붙임
	- Source MAC Address: 클라이언트 컴퓨터의 NIC MAC 주소 (R2의 mac 주소가 설정됨)
	- Destination MAC Address: 동일 네트워크 내의 다음 홉 장비의 MAC 주소(ARP 쿼리를 통해 확인된 값)
	- CRC: 오류 검출

### 4.4.7 Physical Layer
- 동작: 데이터 링크 계층에서 받은 Frame을 전기, 전파, 광 신호로 변환하여 물리적인 전송 매체를 통해 송신함
- PDU: Bit
- 변환: Frame이 0과 1의 비트 스트림으로 변화되어 네트워크를 통해 다음 장치로 전송됨

## 4.5 HAProxy로 패킷 흐름
### 4.5.1 C2 -> SW1
- 신호가 물리적인 전송 매체를 통해 sw1으로 전송됨.
- 스위치에서는 신호를 디코딩하여 MAC 주소를 확인
### 4.5.2 SW1 -> R2
- R2의 mac 주소인 것을 확인한 스위치는 해당 프레임을 다시 신호로 인코딩하여 R2에게 전송
### 4.5.3 R2 -> HAProxy
- R2 라우터에서 신호를 디코딩하고 Network Layer까지 역캡슐화를 진행하여 ip 주소를 확인
- 해당 ip 주소가 HAProxy를 가리키고 있다는 것을 확인하고 arp 테이블에 해당 ip에 매핑되는 mac 주소가 존재하는지 확인(없다면 arp request) MAC 주소를 HAProxy의 주소로 변경하고 캡슐화, 인코딩하여 신호를 HAProxy에게 전달
### 4.5.4 HAProxy (L4)
- 신호를 수신한 HAProxy는 물리 계층부터 전송 계층까지 역캡슐화를 진행
- 설정된 알고리즘에 따라 해당 요청을 전달할 실제 구글 웹 서버를 결정함
- IP/Port를 변경하고 mac 주소를 알고리즘에 따라 웹 서버의 mac 주소로 설정하여 재캡슐화하여 패킷을 보냄

### 4.5.5 Decapsulation
-  웹 서버 NIC가 신호를 비토로 디코딩하고 프레임 헤더의 mac 주소가 자신의 것인지 확인. 일치하면 헤더와 트레일러를 제거하고 패킷을 상위로 올림
-  IP 헤더를 확인. 목적지 ip가 자신의 ip와 일치하는지 확인하고 프로토콜 번호(tcp: 6)을 확인한 뒤 ip 헤더를 제거
-  tcp 헤더를 확인 목적지 포트(80)를 확인하여 해당 포트에서 대기 중인 웹 서버 프로세스(Apache)에게 세그먼트를 전달함. 체크섬을 통해 데이터 오류가 없는지 검증함
-  데이터 스트림을 결합하여 원래의 http request 메시지를 복원 (GET / HTTP/1.1)

## 4.6 http request/response
### 4.6.1 서버 처리
- 웹 서버는 요청받은 리소스를 확인함. 서버 사이드 스크립트가 있으면 실행하고 결과를 생성함
### 4.6.2 응답 생성
- 서버는 HTTP Response Message를 생성함. (html 소스 코드를 담은 HTTP response(200 OK) 메시지)